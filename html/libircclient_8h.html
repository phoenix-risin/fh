<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Bot: include/libircclient.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>include/libircclient.h File Reference</h1>This file defines all prototypes and functions to use libircclient. <a href="#_details">More...</a>
<p>
<code>#include &lt;sys/select.h&gt;</code><br>
<code>#include &quot;<a class="el" href="libirc__errors_8h-source.html">libirc_errors.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="libirc__events_8h-source.html">libirc_events.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="libirc__options_8h-source.html">libirc_options.h</a>&quot;</code><br>

<p>
<a href="libircclient_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#8aaae81dcdc9238af9805d75d0484ef2">IN_INCLUDE_LIBIRC_H</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct irc_session_s&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A libircclient IRC session.  <a href="#0030a976ab3e6a247d57e30fd5979cd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct irc_dcc_session_s&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#25dc31f3073d8dffd01f659d19c76e5e">irc_dcc_session_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A libircclient DCC session.  <a href="#25dc31f3073d8dffd01f659d19c76e5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A DCC session identifier.  <a href="#4136d52803e88f369d728e1e3b0e70f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9">irc_dcc_callback_t</a> )(<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, <a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> id, int status, void *ctx, const char *data, unsigned int length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A common DCC callback, used to inform you about the current DCC state or event.  <a href="#92d4d3f7866bd8c4f1d6df8f05d939f9"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#c5dada35ee77795d8bb77b6701853b98">irc_create_session</a> (<a class="el" href="structirc__callbacks__t.html">irc_callbacks_t</a> *callbacks)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates and initiates a new IRC session.  <a href="#c5dada35ee77795d8bb77b6701853b98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#30c6cea4f149632d1905b097a3a573f7">irc_destroy_session</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys previously created IRC session.  <a href="#30c6cea4f149632d1905b097a3a573f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#121b23c9e131da651175ae779e1b6851">irc_connect</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *server, unsigned short port, const char *server_password, const char *nick, const char *username, const char *realname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiates a connection to IRC server.  <a href="#121b23c9e131da651175ae779e1b6851"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#5729f584833d55510ae114c8ac3d8e99">irc_connect6</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *server, unsigned short port, const char *server_password, const char *nick, const char *username, const char *realname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiates a connection to IRC server using IPv6.  <a href="#5729f584833d55510ae114c8ac3d8e99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#a5f6dd73d3f0bdecb53f53362e253aab">irc_disconnect</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnects a connection to IRC server.  <a href="#a5f6dd73d3f0bdecb53f53362e253aab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#90f826583118cb2e34135cb0e9b26cf8">irc_is_connected</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether the session is connecting/connected to the IRC server.  <a href="#90f826583118cb2e34135cb0e9b26cf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#112631b75eb9997868d73fede17440d0">irc_run</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Goes into forever-loop, processing IRC events and generating callbacks.  <a href="#112631b75eb9997868d73fede17440d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#75d2af4209ad2edbdbff77b0cfcabcab">irc_add_select_descriptors</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, fd_set *in_set, fd_set *out_set, int *maxfd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds IRC socket(s) for the descriptor set to use in select().  <a href="#75d2af4209ad2edbdbff77b0cfcabcab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#4526d10056559eac7bd777437d440170">irc_process_select_descriptors</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, fd_set *in_set, fd_set *out_set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Processes the IRC socket(s), which descriptor(s) are set.  <a href="#4526d10056559eac7bd777437d440170"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#d69addf9c9e45d888a71d6295429e05c">irc_send_raw</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends raw data to the IRC server.  <a href="#d69addf9c9e45d888a71d6295429e05c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#a89bd6efb6dacf53f25ca5518a5aa4ee">irc_cmd_quit</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *reason)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends QUIT command to the IRC server.  <a href="#a89bd6efb6dacf53f25ca5518a5aa4ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#4960c546c2a077e8fb01fc7aa5ae7add">irc_cmd_join</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *channel, const char *key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Joins the new IRC channel.  <a href="#4960c546c2a077e8fb01fc7aa5ae7add"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#db50b9a3a78693266fb0a257b997831b">irc_cmd_part</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Leaves the IRC channel.  <a href="#db50b9a3a78693266fb0a257b997831b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#77e2b2c46c8883a7986180f36ca17247">irc_cmd_invite</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *nick, const char *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invites a user to invite-only channel.  <a href="#77e2b2c46c8883a7986180f36ca17247"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#9b5d3f07ca8a44f0772fc48f677e5bdd">irc_cmd_names</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains a list of users who're in channel.  <a href="#9b5d3f07ca8a44f0772fc48f677e5bdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#1f49929bca3afb8d95b2986dfb480d42">irc_cmd_list</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains a list of active server channels with their topics.  <a href="#1f49929bca3afb8d95b2986dfb480d42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#e088b8e83e3482875ea3d3f970dbb9a2">irc_cmd_topic</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *channel, const char *topic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Views or changes the channel topic.  <a href="#e088b8e83e3482875ea3d3f970dbb9a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#63489434dcf78d454389b7744624c1e7">irc_cmd_channel_mode</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *channel, const char *mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Views or changes the channel mode.  <a href="#63489434dcf78d454389b7744624c1e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#71b0c8a534600d2b354be35e28735513">irc_cmd_user_mode</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Views or changes your own user mode.  <a href="#71b0c8a534600d2b354be35e28735513"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#19ae1ad61caf031e5c2dc950e24b7370">irc_cmd_nick</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *newnick)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes your nick.  <a href="#19ae1ad61caf031e5c2dc950e24b7370"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#7cfe0b48a060c5291ef1d59a3ea79b4f">irc_cmd_whois</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *nick)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries the information about the nick.  <a href="#7cfe0b48a060c5291ef1d59a3ea79b4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#8c2ec03f1a9ce7c739e11b64fd088ae5">irc_cmd_msg</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *nch, const char *text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends the message to the nick or to the channel.  <a href="#8c2ec03f1a9ce7c739e11b64fd088ae5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#09c7e471bf4062b57df10d31ee275fc5">irc_cmd_me</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *nch, const char *text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends the /me (CTCP ACTION) message to the nick or to the channel.  <a href="#09c7e471bf4062b57df10d31ee275fc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#f537698d7ec582701fa3473a2dd6775f">irc_cmd_notice</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *nch, const char *text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends the notice to the nick or to the channel.  <a href="#f537698d7ec582701fa3473a2dd6775f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#47a6c7a2b3f96c9fe41e7df82f0dbd7c">irc_cmd_kick</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *nick, const char *channel, const char *reason)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kick some lazy ass out of channel.  <a href="#47a6c7a2b3f96c9fe41e7df82f0dbd7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#d3eb9e56b5988f157e6f4a9b73145382">irc_cmd_ctcp_request</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *nick, const char *request)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a CTCP request.  <a href="#d3eb9e56b5988f157e6f4a9b73145382"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#62cba0ecb13b0d602403e77bbe78550e">irc_cmd_ctcp_reply</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, const char *nick, const char *reply)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a reply to the CTCP request.  <a href="#62cba0ecb13b0d602403e77bbe78550e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#217df7c7c7dc5e60678dd14e24e41f03">irc_target_get_nick</a> (const char *target, char *nick, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the nick part from the target.  <a href="#217df7c7c7dc5e60678dd14e24e41f03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#5929f96c251be831d1de66e6bba6299c">irc_target_get_host</a> (const char *target, char *nick, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the host part from the target.  <a href="#5929f96c251be831d1de66e6bba6299c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#d6958aac6d67f595966949d1ec5ae4a0">irc_dcc_chat</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, void *ctx, const char *nick, <a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9">irc_dcc_callback_t</a> callback, <a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> *dccid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiates a DCC CHAT.  <a href="#d6958aac6d67f595966949d1ec5ae4a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#b98b7ea58a36d7649c2dca6c4b3c8a7d">irc_dcc_msg</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, <a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> dccid, const char *text)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends the message to the specific DCC CHAT.  <a href="#b98b7ea58a36d7649c2dca6c4b3c8a7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#43f747d3b2252109f9d811ea8414745b">irc_dcc_accept</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, <a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> dccid, void *ctx, <a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9">irc_dcc_callback_t</a> callback)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accepts a remote DCC CHAT or DCC RECVFILE request.  <a href="#43f747d3b2252109f9d811ea8414745b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#3ff4ca78d346b7acf847cf28a7211bf4">irc_dcc_decline</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, <a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> dccid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declines a remote DCC CHAT or DCC RECVFILE request.  <a href="#3ff4ca78d346b7acf847cf28a7211bf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#f9e8a307113cd27d08e082fda6264262">irc_dcc_sendfile</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, void *ctx, const char *nick, const char *filename, <a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9">irc_dcc_callback_t</a> callback, <a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> *dccid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a file via DCC.  <a href="#f9e8a307113cd27d08e082fda6264262"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#8b8aa3363ee93cc395bc89ac5cc9501c">irc_dcc_destroy</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, <a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> dccid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a DCC session.  <a href="#8b8aa3363ee93cc395bc89ac5cc9501c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#ebc090ad2392569b1998d7e2354c7bc7">irc_get_version</a> (unsigned int *high, unsigned int *low)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtains a libircclient version.  <a href="#ebc090ad2392569b1998d7e2354c7bc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#e0cf439a36aafce4abab8f4cce5ac5ff">irc_set_ctx</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, void *ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the IRC session context.  <a href="#e0cf439a36aafce4abab8f4cce5ac5ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#341a8954613f29c7ff5a92413398ce7d">irc_get_ctx</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the IRC session context.  <a href="#341a8954613f29c7ff5a92413398ce7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d">irc_errno</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last error code.  <a href="#3a18336093ee74751244d996bc32247d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#fdc70ca04626818d2fd9a55da0b90e5f">irc_strerror</a> (int ircerrno)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the text error message associated with this error code.  <a href="#fdc70ca04626818d2fd9a55da0b90e5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#c5d81f651f1441690f3f59c3ddccaa48">irc_option_set</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, unsigned int option)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the libircclient option.  <a href="#c5d81f651f1441690f3f59c3ddccaa48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#f56687ccad2045204ae23f70d2f54860">irc_option_reset</a> (<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, unsigned int option)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the libircclient option.  <a href="#f56687ccad2045204ae23f70d2f54860"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#2b94751f30cf4cdf444345808fe4ed6c">irc_color_strip_from_mirc</a> (const char *message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all the color codes and format options.  <a href="#2b94751f30cf4cdf444345808fe4ed6c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#bb894bace7c39c70b5582bcdb4052bea">irc_color_convert_from_mirc</a> (const char *message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts all the color codes and format options to libircclient colors.  <a href="#bb894bace7c39c70b5582bcdb4052bea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libircclient_8h.html#7a9a3490741e2883695759ba5f4adc1e">irc_color_convert_to_mirc</a> (const char *message)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts all the color codes from libircclient format to mIRC.  <a href="#7a9a3490741e2883695759ba5f4adc1e"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This file defines all prototypes and functions to use libircclient. 
<p>
<dl class="author" compact><dt><b>Author:</b></dt><dd>George Yunaev </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd>1.5 </dd></dl>
<dl class="date" compact><dt><b>Date:</b></dt><dd>01.2012 libircclient is a small but powerful library, which implements client-server IRC protocol. It is designed to be small, fast, portable and compatible to RFC standards, and most IRC clients. libircclient features include:<ul>
<li>Full multi-threading support.</li><li>Single threads handles all the IRC processing.</li><li>Support for single-threaded applications, and socket-based applications, which use select()</li><li>Synchronous and asynchronous interfaces.</li><li>CTCP support with optional build-in reply code.</li><li>Flexible DCC support, including both DCC chat, and DCC file transfer.</li><li>Can both initiate and react to initiated DCC.</li><li>Can accept or decline DCC sessions asynchronously.</li><li>Plain C interface and implementation (possible to use from C++ code, obviously)</li><li>Compatible with RFC 1459 and most IRC clients.</li><li>SSL support if compiled with --enable-openssl.</li><li>Free, licensed under LGPL license.</li></ul>
</dd></dl>
Note that to use libircclient, only <a class="el" href="libircclient_8h.html" title="This file defines all prototypes and functions to use libircclient.">libircclient.h</a> should be included into your program. Do not include other libirc_* headers. <hr><h2>Define Documentation</h2>
<a class="anchor" name="8aaae81dcdc9238af9805d75d0484ef2"></a><!-- doxytag: member="libircclient.h::IN_INCLUDE_LIBIRC_H" ref="8aaae81dcdc9238af9805d75d0484ef2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IN_INCLUDE_LIBIRC_H          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="92d4d3f7866bd8c4f1d6df8f05d939f9"></a><!-- doxytag: member="libircclient.h::irc_dcc_callback_t" ref="92d4d3f7866bd8c4f1d6df8f05d939f9" args=")(irc_session_t *session, irc_dcc_t id, int status, void *ctx, const char *data, unsigned int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9">irc_dcc_callback_t</a>)(<a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *session, <a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> id, int status, void *ctx, const char *data, unsigned int length)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A common DCC callback, used to inform you about the current DCC state or event. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An IRC session which generates the callback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>A DCC session id. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>An error status. 0 means no error, otherwise error code. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>A user-supplied context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Data supplied (if available) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>data length (if available)</td></tr>
  </table>
</dl>
This callback is called for all DCC functions when state change occurs.<p>
For DCC CHAT, the callback is called in next circumstances:<ul>
<li><em>status</em> is LIBIRC_ERR_CLOSED: connection is closed by remote peer. After returning from the callback, the DCC session is automatically destroyed.</li><li><em>status</em> is neither 0 nor LIBIRC_ERR_CLOSED: socket I/O error (connect error, accept error, recv error, send error). After returning from the callback, the DCC session is automatically destroyed.</li><li><em>status</em> is 0: new chat message received, <em>data</em> contains the message (null-terminated string), <em>length</em> contains the message length.</li></ul>
<p>
For DCC SEND, while file is sending, callback called in next circumstances:<ul>
<li><em>status</em> is neither 0 nor LIBIRC_ERR_CLOSED: socket I/O error (connect error, accept error, recv error, send error). After returning from the callback, the DCC session is automatically destroyed.</li><li><em>status</em> is 0: new data received, <em>data</em> contains the data received, <em>length</em> contains the amount of data received.</li></ul>
<p>
For DCC RECV, while file is sending, callback called in next circumstances:<ul>
<li><em>status</em> is neither 0 nor LIBIRC_ERR_CLOSED: socket I/O error (connect error, accept error, recv error, send error). After returning from the callback, the DCC session is automatically destroyed.</li><li><em>status</em> is 0, and <em>data</em> is 0: file has been received successfully. After returning from the callback, the DCC session is automatically destroyed.</li><li><em>status</em> is 0, and <em>data</em> is not 0: new data received, <em>data</em> contains the data received, <em>length</em> contains the amount of data received. </li></ul>

</div>
</div><p>
<a class="anchor" name="25dc31f3073d8dffd01f659d19c76e5e"></a><!-- doxytag: member="libircclient.h::irc_dcc_session_t" ref="25dc31f3073d8dffd01f659d19c76e5e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct irc_dcc_session_s <a class="el" href="libircclient_8h.html#25dc31f3073d8dffd01f659d19c76e5e">irc_dcc_session_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A libircclient DCC session. 
<p>
This structure describes a DCC session used by libircclient. Its members are internal to libircclient, and should not be used directly. 
</div>
</div><p>
<a class="anchor" name="4136d52803e88f369d728e1e3b0e70f7"></a><!-- doxytag: member="libircclient.h::irc_dcc_t" ref="4136d52803e88f369d728e1e3b0e70f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A DCC session identifier. 
<p>
The irc_dcc_t type is a DCC session identifier, used to identify the DCC sessions in callbacks and various functions. 
</div>
</div><p>
<a class="anchor" name="0030a976ab3e6a247d57e30fd5979cd5"></a><!-- doxytag: member="libircclient.h::irc_session_t" ref="0030a976ab3e6a247d57e30fd5979cd5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct irc_session_s <a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A libircclient IRC session. 
<p>
This structure describes an IRC session. Its members are internal to libircclient, and should not be used directly. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="75d2af4209ad2edbdbff77b0cfcabcab"></a><!-- doxytag: member="libircclient.h::irc_add_select_descriptors" ref="75d2af4209ad2edbdbff77b0cfcabcab" args="(irc_session_t *session, fd_set *in_set, fd_set *out_set, int *maxfd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_add_select_descriptors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&nbsp;</td>
          <td class="paramname"> <em>in_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&nbsp;</td>
          <td class="paramname"> <em>out_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>maxfd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds IRC socket(s) for the descriptor set to use in select(). 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_set</em>&nbsp;</td><td>A FD_IN descriptor set for select() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_set</em>&nbsp;</td><td>A FD_OUT descriptor set for select() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxfd</em>&nbsp;</td><td>A max descriptor found.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>.</dd></dl>
This function should be used when you already have a program with select() based data processing. You prepare your descriptors, call this function to add session's descriptor(s) into set, and then call select(). When it returns, you should call irc_add_select_descriptors, which sends/recvs all available data, parses received data, calls your callbacks(!), and returns. Then you can process your sockets from set. See the example.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#4526d10056559eac7bd777437d440170" title="Processes the IRC socket(s), which descriptor(s) are set.">irc_process_select_descriptors</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="63489434dcf78d454389b7744624c1e7"></a><!-- doxytag: member="libircclient.h::irc_cmd_channel_mode" ref="63489434dcf78d454389b7744624c1e7" args="(irc_session_t *session, const char *channel, const char *mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_channel_mode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Views or changes the channel mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel name to invite to. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A channel mode, described below. If NULL, the channel mode is not changed, just the old mode is returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
The <a class="el" href="libircclient_8h.html#63489434dcf78d454389b7744624c1e7" title="Views or changes the channel mode.">irc_cmd_channel_mode()</a> is used to change or view the channel modes. The <em>channel</em> mode is returned if the <em>mode</em> is NULL. If the <em>mode</em> is not NULL, the mode for the <em>channel</em> will be changed. Note that, only channel operators can change the channel modes.<p>
Channel mode is represended by the letters combination. Every letter has its own meaning in channel modes. Most channel mode letters are boolean (i.e. could only be set or reset), but a few channel mode letters accept a parameter. All channel options are set by adding a plus sign before the letter, and reset by adding a minus sign before the letter.<p>
Here is the list of 'standard' channel modes:<p>
<ul>
<li><em>o</em> <em>nickname</em> - gives (+o nick) or takes (-o nick) the channel operator privileges from a <em>nickname</em>. This mode affects the users in channel, not the channel itself. Examples: "+o tim", "-o watson".</li></ul>
<p>
<ul>
<li><em>p</em> - sets (+p) or resets (-p) private channel flag. Private channels are shown in channel list as 'Prv', without the topic.</li></ul>
<p>
<ul>
<li><em>s</em> - sets (+p) or resets (-p) secret channel flag. Secret channels aren't shown in channel list at all.</li></ul>
<p>
<ul>
<li><em>i</em> - sets (+i) or resets (-i) invite-only channel flag. When the flag is set, only the people who are invited by <a class="el" href="libircclient_8h.html#77e2b2c46c8883a7986180f36ca17247" title="Invites a user to invite-only channel.">irc_cmd_invite()</a>, can join this channel.</li></ul>
<p>
<ul>
<li><em>t</em> - sets (+t) or resets (-t) topic settable by channel operator only flag. When the flag is set, only the channel operators can change the channel topic.</li></ul>
<p>
<ul>
<li><em>n</em> - sets (+n) or resets (-n) the protection from the clients outside the channel. When the <em>+n</em> mode is set, only the clients, who are in channel, can send the messages to the channel.</li></ul>
<p>
<ul>
<li><em>m</em> - sets (+m) or resets (-m) the moderation of the channel. When the moderation mode is set, only channel operators and the users who have the <em>+v</em> user mode can speak in the channel.</li></ul>
<p>
<ul>
<li><em>v</em> <em>nickname</em> - gives (+v nick) or takes (-v nick) from user the ability to speak on a moderated channel. Examples: "+v tim", "-v watson".</li></ul>
<p>
<ul>
<li><em>l</em> <em>number</em> - sets (+l 20) or removes (-l) the restriction of maximum users in channel. When the restriction is set, and there is a number of users in the channel, no one can join the channel anymore.</li></ul>
<p>
<ul>
<li><em>k</em> <em>key</em> - sets (+k secret) or removes (-k) the password from the channel. When the restriction is set, any user joining the channel required to provide a channel key.</li></ul>
<p>
<ul>
<li><em>b</em> <em>mask</em> - sets (+b *!*@*.mil) or removes (-b *!*@*.mil) the ban mask on a user to keep him out of channel. Note that to remove the ban you must specify the ban mask to remove, not just "-b".</li></ul>
<p>
Note that the actual list of channel modes depends on the IRC server, and can be bigger. If you know the popular channel modes, which aren't mentioned here - please contact me at <a href="mailto:tim@krasnogorsk.ru">tim@krasnogorsk.ru</a><p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#b3fc9166c154ed2b99c0294f5ce31777" title="461 &lt;command&gt; :Not enough parameters">LIBIRC_RFC_ERR_NEEDMOREPARAMS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#45e953e4c730a2f091d74430eeac1d57" title="482 &lt;channel&gt; :You&#39;re not channel operator">LIBIRC_RFC_ERR_CHANOPRIVSNEEDED</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#43267525d047db03b1c8f402cfe549f3" title="467 &lt;channel&gt; :Channel key already set">LIBIRC_RFC_ERR_KEYSET</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#66d80c7acd49ba08f1a14b8775347ed1" title="472 &lt;char&gt; :is unknown mode char to me for &lt;channel&gt;">LIBIRC_RFC_ERR_UNKNOWNMODE</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#2c0be54b246f18fb20c2c9edbc671649" title="403 &lt;channel name&gt; :No such channel">LIBIRC_RFC_ERR_NOSUCHCHANNEL</a></li></ul>
<p>
And the mode information is given using following reply codes:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#ce33e328528f4ae2e7843478839301e5" title="324 &lt;channel&gt; &lt;mode&gt; &lt;mode params&gt;">LIBIRC_RFC_RPL_CHANNELMODEIS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#a188a0d60499bb3546fdc75b07ee5680" title="367 &lt;channel&gt; &lt;banmask&gt;">LIBIRC_RFC_RPL_BANLIST</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#6040ae147ea3044f201f314fec1a1791" title="368 &lt;channel&gt; :End of channel ban list">LIBIRC_RFC_RPL_ENDOFBANLIST</a></li></ul>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#e088b8e83e3482875ea3d3f970dbb9a2" title="Views or changes the channel topic.">irc_cmd_topic</a> <a class="el" href="libircclient_8h.html#1f49929bca3afb8d95b2986dfb480d42" title="Obtains a list of active server channels with their topics.">irc_cmd_list</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="62cba0ecb13b0d602403e77bbe78550e"></a><!-- doxytag: member="libircclient.h::irc_cmd_ctcp_reply" ref="62cba0ecb13b0d602403e77bbe78550e" args="(irc_session_t *session, const char *nick, const char *reply)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_ctcp_reply           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>reply</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates a reply to the CTCP request. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A target nick to send request to. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reply</em>&nbsp;</td><td>A reply string. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to send a reply to the CTCP request, generated by <a class="el" href="structirc__callbacks__t.html#5f5d386a4df0d1334ffb96b3c406355f">irc_callbacks_t::event_ctcp_req</a>. Note that you will not receive this event unless you specify your own handler as <code>event_ctcp_req</code> callback during the IRC session initialization.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#73d5c17577fddd176f2d89e15b657c1a" title="411 :No recipient given (&lt;command&gt;)">LIBIRC_RFC_ERR_NORECIPIENT</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#c9851022435108cc6074c8cab2311b58" title="412 :No text to send">LIBIRC_RFC_ERR_NOTEXTTOSEND</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#3624990fe128d867c11b213228e62df8" title="404 &lt;channel name&gt; :Cannot send to channel">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#fcad763cc97b268aa585311350989dca" title="413 &lt;mask&gt; :No toplevel domain specified">LIBIRC_RFC_ERR_NOTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#4cf5ceeec3305180731860436650c955" title="414 &lt;mask&gt; :Wildcard in toplevel domain">LIBIRC_RFC_ERR_WILDTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#807eab621113410281fd574de71236ea" title="407 &lt;target&gt; :&lt;error code&gt; recipients. &lt;abort message&gt;">LIBIRC_RFC_ERR_TOOMANYTARGETS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a> </li></ul>

</div>
</div><p>
<a class="anchor" name="d3eb9e56b5988f157e6f4a9b73145382"></a><!-- doxytag: member="libircclient.h::irc_cmd_ctcp_request" ref="d3eb9e56b5988f157e6f4a9b73145382" args="(irc_session_t *session, const char *nick, const char *request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_ctcp_request           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>request</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates a CTCP request. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A target nick to send request to. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>request</em>&nbsp;</td><td>A request string. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to send a CTCP request. There are four CTCP requests supported by Mirc: VERSION - get the client software name and version FINGER - get the client username, host and real name. PING - get the client delay. TIME - get the client local time.<p>
A reply to the CTCP request will be sent by the <a class="el" href="structirc__callbacks__t.html#1e967e7534502bce5434dd4d4415bdd8">irc_callbacks_t::event_ctcp_rep</a> callback; be sure to define it.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#73d5c17577fddd176f2d89e15b657c1a" title="411 :No recipient given (&lt;command&gt;)">LIBIRC_RFC_ERR_NORECIPIENT</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#c9851022435108cc6074c8cab2311b58" title="412 :No text to send">LIBIRC_RFC_ERR_NOTEXTTOSEND</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#3624990fe128d867c11b213228e62df8" title="404 &lt;channel name&gt; :Cannot send to channel">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#fcad763cc97b268aa585311350989dca" title="413 &lt;mask&gt; :No toplevel domain specified">LIBIRC_RFC_ERR_NOTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#4cf5ceeec3305180731860436650c955" title="414 &lt;mask&gt; :Wildcard in toplevel domain">LIBIRC_RFC_ERR_WILDTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#807eab621113410281fd574de71236ea" title="407 &lt;target&gt; :&lt;error code&gt; recipients. &lt;abort message&gt;">LIBIRC_RFC_ERR_TOOMANYTARGETS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li></ul>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structirc__callbacks__t.html#1e967e7534502bce5434dd4d4415bdd8">irc_callbacks_t::event_ctcp_rep</a> <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="77e2b2c46c8883a7986180f36ca17247"></a><!-- doxytag: member="libircclient.h::irc_cmd_invite" ref="77e2b2c46c8883a7986180f36ca17247" args="(irc_session_t *session, const char *nick, const char *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_invite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invites a user to invite-only channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A nick to invite. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel name to invite to. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to invite someone to invite-only channel. "Invite-only" is a channel mode, which restricts anyone, except invided, to join this channel. After invitation, the user could join this channel. The user, who is invited, will receive the <a class="el" href="structirc__callbacks__t.html#e5f3325ab13c3a36ed84435e3bcf7b61">irc_callbacks_t::event_invite</a> event. Note that you must be a channel operator to INVITE the users.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#b3fc9166c154ed2b99c0294f5ce31777" title="461 &lt;command&gt; :Not enough parameters">LIBIRC_RFC_ERR_NEEDMOREPARAMS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li>LIBIRC_RFC_ERR_ERR_USERONCHANNEL</li><li>LIBIRC_RFC_ERR_ERR_CHANOPRIVSNEEDED</li></ul>
<p>
And on success one of the following replies returned:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#5de83e9710137226a986fdc6aece31da" title="341 &lt;channel&gt; &lt;nick&gt;">LIBIRC_RFC_RPL_INVITING</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#54aa2b97df3fc570572e68fc88647143" title="301 &lt;nick&gt; :&lt;away message&gt;">LIBIRC_RFC_RPL_AWAY</a></li></ul>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structirc__callbacks__t.html#e5f3325ab13c3a36ed84435e3bcf7b61">irc_callbacks_t::event_invite</a> <a class="el" href="libircclient_8h.html#63489434dcf78d454389b7744624c1e7" title="Views or changes the channel mode.">irc_cmd_channel_mode</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4960c546c2a077e8fb01fc7aa5ae7add"></a><!-- doxytag: member="libircclient.h::irc_cmd_join" ref="4960c546c2a077e8fb01fc7aa5ae7add" args="(irc_session_t *session, const char *channel, const char *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_join           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Joins the new IRC channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel name to join to. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>Channel password. May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to JOIN the IRC channel. If the channel is not exist, it will be automatically created by the IRC server. Note that to JOIN the password-protected channel, you must know the password, and specify it in the <em>key</em> argument.<p>
If join is successful, the <a class="el" href="structirc__callbacks__t.html#8f24c0e2b05425c2308a0106dbaaffec">irc_callbacks_t::event_join</a> is called (with <em>origin</em> == your nickname), then you are sent the channel's topic (using <a class="el" href="libirc__rfcnumeric_8h.html#02d7f6f775a11abd3c09bca16d6cdc59" title="332 &lt;channel&gt; :&lt;topic&gt;">LIBIRC_RFC_RPL_TOPIC</a>) and the list of users who are on the channel (using <a class="el" href="libirc__rfcnumeric_8h.html#7fc1ff023f7824d91d5f5567997f0fd3" title="353 ( &quot;=">LIBIRC_RFC_RPL_NAMREPLY</a>), which includes the user joining - namely you.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#b3fc9166c154ed2b99c0294f5ce31777" title="461 &lt;command&gt; :Not enough parameters">LIBIRC_RFC_ERR_NEEDMOREPARAMS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#c5bf83f758e914ca36d5f379e5819103" title="474 &lt;channel&gt; :Cannot join channel (+b)">LIBIRC_RFC_ERR_BANNEDFROMCHAN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#dfa3659a762a5023cd37615a54f70a2e" title="473 &lt;channel&gt; :Cannot join channel (+i)">LIBIRC_RFC_ERR_INVITEONLYCHAN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#04a2e9664d25bece875e5c207c6a2697" title="475 &lt;channel&gt; :Cannot join channel (+k)">LIBIRC_RFC_ERR_BADCHANNELKEY</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#8644827c4d45e5669a342b1d70a0904e" title="471 &lt;channel&gt; :Cannot join channel (+l)">LIBIRC_RFC_ERR_CHANNELISFULL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#6e40a8054eb0a0c0c6882cd97f344853" title="476 &lt;channel&gt; :Bad Channel Mask">LIBIRC_RFC_ERR_BADCHANMASK</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#2c0be54b246f18fb20c2c9edbc671649" title="403 &lt;channel name&gt; :No such channel">LIBIRC_RFC_ERR_NOSUCHCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#784de3929f568ce298c37c42acb4bfef" title="405 &lt;channel name&gt; :You have joined too many channels">LIBIRC_RFC_ERR_TOOMANYCHANNELS</a></li></ul>
<p>
And on success the following replies returned:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#02d7f6f775a11abd3c09bca16d6cdc59" title="332 &lt;channel&gt; :&lt;topic&gt;">LIBIRC_RFC_RPL_TOPIC</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#7fc1ff023f7824d91d5f5567997f0fd3" title="353 ( &quot;=">LIBIRC_RFC_RPL_NAMREPLY</a> </li></ul>

</div>
</div><p>
<a class="anchor" name="47a6c7a2b3f96c9fe41e7df82f0dbd7c"></a><!-- doxytag: member="libircclient.h::irc_cmd_kick" ref="47a6c7a2b3f96c9fe41e7df82f0dbd7c" args="(irc_session_t *session, const char *nick, const char *channel, const char *reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_kick           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Kick some lazy ass out of channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A nick to kick. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel to kick this nick out of. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>A reason to kick. May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to kick a person out of channel. Note that you must be a channel operator to kick anyone.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#b3fc9166c154ed2b99c0294f5ce31777" title="461 &lt;command&gt; :Not enough parameters">LIBIRC_RFC_ERR_NEEDMOREPARAMS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#6e40a8054eb0a0c0c6882cd97f344853" title="476 &lt;channel&gt; :Bad Channel Mask">LIBIRC_RFC_ERR_BADCHANMASK</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#2c0be54b246f18fb20c2c9edbc671649" title="403 &lt;channel name&gt; :No such channel">LIBIRC_RFC_ERR_NOSUCHCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#45e953e4c730a2f091d74430eeac1d57" title="482 &lt;channel&gt; :You&#39;re not channel operator">LIBIRC_RFC_ERR_CHANOPRIVSNEEDED</a></li></ul>
<p>
On success the <a class="el" href="structirc__callbacks__t.html#1a8194bfdbf2622e9384fbd1ac1a67d7">irc_callbacks_t::event_kick</a> event will be generated.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1f49929bca3afb8d95b2986dfb480d42"></a><!-- doxytag: member="libircclient.h::irc_cmd_list" ref="1f49929bca3afb8d95b2986dfb480d42" args="(irc_session_t *session, const char *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_list           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains a list of active server channels with their topics. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel name(s) to list. May be NULL, in which case all the channels will be listed. It is possible to specify more than a single channel, but several channel names should be separated by a comma.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to ask the IRC server for the active (existing) channels list. The list will be returned using LIBIRC_RFC_RPL_LISTSTART - <a class="el" href="libirc__rfcnumeric_8h.html#7cd68428c26cc9867a1b35a25b4acb64" title="322 &lt;channel&gt; &lt;# visible&gt; :&lt;topic&gt;">LIBIRC_RFC_RPL_LIST</a> - <a class="el" href="libirc__rfcnumeric_8h.html#b986ca08f325c8113fbada41a99c84bf" title="323 :End of LIST">LIBIRC_RFC_RPL_LISTEND</a> sequence. Note that "private" channels are listed (without their topics) as channel "Prv" unless the client generating the LIST query is actually on that channel. Likewise, secret channels are not listed at all unless the client is a member of the channel in question.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#8108addfd19326f00eacd71c26809348" title="402 &lt;server name&gt; :No such server">LIBIRC_RFC_ERR_NOSUCHSERVER</a></li></ul>
<p>
And the channel list is returned using the following reply codes:<ul>
<li>LIBIRC_RFC_RPL_LISTSTART</li><li><a class="el" href="libirc__rfcnumeric_8h.html#b986ca08f325c8113fbada41a99c84bf" title="323 :End of LIST">LIBIRC_RFC_RPL_LISTEND</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#7cd68428c26cc9867a1b35a25b4acb64" title="322 &lt;channel&gt; &lt;# visible&gt; :&lt;topic&gt;">LIBIRC_RFC_RPL_LIST</a> </li></ul>

</div>
</div><p>
<a class="anchor" name="09c7e471bf4062b57df10d31ee275fc5"></a><!-- doxytag: member="libircclient.h::irc_cmd_me" ref="09c7e471bf4062b57df10d31ee275fc5" args="(irc_session_t *session, const char *nch, const char *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_me           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends the /me (CTCP ACTION) message to the nick or to the channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nch</em>&nbsp;</td><td>A target nick or channel. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Action message text. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to send the /me message to channel or private. As for irc_cmd_msg, the target is determined by <em>nch</em> argument.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#73d5c17577fddd176f2d89e15b657c1a" title="411 :No recipient given (&lt;command&gt;)">LIBIRC_RFC_ERR_NORECIPIENT</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#c9851022435108cc6074c8cab2311b58" title="412 :No text to send">LIBIRC_RFC_ERR_NOTEXTTOSEND</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#3624990fe128d867c11b213228e62df8" title="404 &lt;channel name&gt; :Cannot send to channel">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#fcad763cc97b268aa585311350989dca" title="413 &lt;mask&gt; :No toplevel domain specified">LIBIRC_RFC_ERR_NOTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#4cf5ceeec3305180731860436650c955" title="414 &lt;mask&gt; :Wildcard in toplevel domain">LIBIRC_RFC_ERR_WILDTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#807eab621113410281fd574de71236ea" title="407 &lt;target&gt; :&lt;error code&gt; recipients. &lt;abort message&gt;">LIBIRC_RFC_ERR_TOOMANYTARGETS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li></ul>
<p>
On success there is NOTHING generated. However, a <a class="el" href="libirc__rfcnumeric_8h.html#54aa2b97df3fc570572e68fc88647143" title="301 &lt;nick&gt; :&lt;away message&gt;">LIBIRC_RFC_RPL_AWAY</a> reply can be also generated.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#8c2ec03f1a9ce7c739e11b64fd088ae5" title="Sends the message to the nick or to the channel.">irc_cmd_msg</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c2ec03f1a9ce7c739e11b64fd088ae5"></a><!-- doxytag: member="libircclient.h::irc_cmd_msg" ref="8c2ec03f1a9ce7c739e11b64fd088ae5" args="(irc_session_t *session, const char *nch, const char *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">irc_cmd_msg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends the message to the nick or to the channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nch</em>&nbsp;</td><td>A target nick or channel. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Message text. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to send the channel or private messages. The target is determined by <em>nch</em> argument: if it describes nick, this will be a private message, if a channel name - public (channel) message. Note that depending on channel modes, you may be required to join the channel to send the channel messages.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#73d5c17577fddd176f2d89e15b657c1a" title="411 :No recipient given (&lt;command&gt;)">LIBIRC_RFC_ERR_NORECIPIENT</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#c9851022435108cc6074c8cab2311b58" title="412 :No text to send">LIBIRC_RFC_ERR_NOTEXTTOSEND</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#3624990fe128d867c11b213228e62df8" title="404 &lt;channel name&gt; :Cannot send to channel">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#fcad763cc97b268aa585311350989dca" title="413 &lt;mask&gt; :No toplevel domain specified">LIBIRC_RFC_ERR_NOTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#4cf5ceeec3305180731860436650c955" title="414 &lt;mask&gt; :Wildcard in toplevel domain">LIBIRC_RFC_ERR_WILDTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#807eab621113410281fd574de71236ea" title="407 &lt;target&gt; :&lt;error code&gt; recipients. &lt;abort message&gt;">LIBIRC_RFC_ERR_TOOMANYTARGETS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li></ul>
<p>
On success there is NOTHING generated. 
</div>
</div><p>
<a class="anchor" name="9b5d3f07ca8a44f0772fc48f677e5bdd"></a><!-- doxytag: member="libircclient.h::irc_cmd_names" ref="9b5d3f07ca8a44f0772fc48f677e5bdd" args="(irc_session_t *session, const char *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_names           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains a list of users who're in channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel name(s) to obtain user list. Must not be NULL. It is possible to specify more than a single channel, but several channel names should be separated by a comma.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to ask the IRC server for the list of the users who're in specified channel. You can list all nicknames that are visible to you on any channel that you can see. The list of users will be returned using RPL_NAMREPLY and RPL_ENDOFNAMES numeric codes.<p>
The channel names are returned by <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a> using the following reply codes:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#7fc1ff023f7824d91d5f5567997f0fd3" title="353 ( &quot;=">LIBIRC_RFC_RPL_NAMREPLY</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#ed45893cd1a15247dc7200d16a224a76" title="366 &lt;channel&gt; :End of NAMES list">LIBIRC_RFC_RPL_ENDOFNAMES</a> </li></ul>

</div>
</div><p>
<a class="anchor" name="19ae1ad61caf031e5c2dc950e24b7370"></a><!-- doxytag: member="libircclient.h::irc_cmd_nick" ref="19ae1ad61caf031e5c2dc950e24b7370" args="(irc_session_t *session, const char *newnick)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_nick           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newnick</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes your nick. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newnick</em>&nbsp;</td><td>A new nick. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to change your current nick to another nick. Note that such a change is not always possible; for example you cannot change nick to the existing nick, or (on some servers) to the registered nick.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#c754b9522b1f4c4376f809d2e3acbee4" title="431 :No nickname given">LIBIRC_RFC_ERR_NONICKNAMEGIVEN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#177a2b46f518e603271b3d55ae2f84ab" title="432 &lt;nick&gt; :Erroneous nickname">LIBIRC_RFC_ERR_ERRONEUSNICKNAME</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#2dabe26bb4ab3b90974a6a645f7d7545" title="433 &lt;nick&gt; :Nickname is already in use">LIBIRC_RFC_ERR_NICKNAMEINUSE</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#929657e2facbf0e46a540aa8e7516774" title="436 &lt;nick&gt; :Nickname collision KILL from &lt;user&gt;@&lt;host&gt;">LIBIRC_RFC_ERR_NICKCOLLISION</a> </li></ul>

</div>
</div><p>
<a class="anchor" name="f537698d7ec582701fa3473a2dd6775f"></a><!-- doxytag: member="libircclient.h::irc_cmd_notice" ref="f537698d7ec582701fa3473a2dd6775f" args="(irc_session_t *session, const char *nch, const char *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_notice           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends the notice to the nick or to the channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nch</em>&nbsp;</td><td>A target nick or channel. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Notice text. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to send the channel or private notices. The target is determined by <em>nch</em> argument: if it describes nick, this will be a private message, if a channel name - public (channel) message. Note that depending on channel modes, you may be required to join the channel to send the channel notices.<p>
The only difference between message and notice is that, according to RFC 1459, you must not automatically reply to NOTICE messages.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#73d5c17577fddd176f2d89e15b657c1a" title="411 :No recipient given (&lt;command&gt;)">LIBIRC_RFC_ERR_NORECIPIENT</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#c9851022435108cc6074c8cab2311b58" title="412 :No text to send">LIBIRC_RFC_ERR_NOTEXTTOSEND</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#3624990fe128d867c11b213228e62df8" title="404 &lt;channel name&gt; :Cannot send to channel">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#fcad763cc97b268aa585311350989dca" title="413 &lt;mask&gt; :No toplevel domain specified">LIBIRC_RFC_ERR_NOTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#4cf5ceeec3305180731860436650c955" title="414 &lt;mask&gt; :Wildcard in toplevel domain">LIBIRC_RFC_ERR_WILDTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#807eab621113410281fd574de71236ea" title="407 &lt;target&gt; :&lt;error code&gt; recipients. &lt;abort message&gt;">LIBIRC_RFC_ERR_TOOMANYTARGETS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li></ul>
<p>
On success there is NOTHING generated. On notices sent to target nick, a <a class="el" href="libirc__rfcnumeric_8h.html#54aa2b97df3fc570572e68fc88647143" title="301 &lt;nick&gt; :&lt;away message&gt;">LIBIRC_RFC_RPL_AWAY</a> reply may be generated.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#8c2ec03f1a9ce7c739e11b64fd088ae5" title="Sends the message to the nick or to the channel.">irc_cmd_msg</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="db50b9a3a78693266fb0a257b997831b"></a><!-- doxytag: member="libircclient.h::irc_cmd_part" ref="db50b9a3a78693266fb0a257b997831b" args="(irc_session_t *session, const char *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_part           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Leaves the IRC channel. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel name to leave. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function is used to leave the IRC channel you've already joined to. An attempt to leave the channel you aren't in results a <a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a> server error.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#b3fc9166c154ed2b99c0294f5ce31777" title="461 &lt;command&gt; :Not enough parameters">LIBIRC_RFC_ERR_NEEDMOREPARAMS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#2c0be54b246f18fb20c2c9edbc671649" title="403 &lt;channel name&gt; :No such channel">LIBIRC_RFC_ERR_NOSUCHCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a> </li></ul>

</div>
</div><p>
<a class="anchor" name="a89bd6efb6dacf53f25ca5518a5aa4ee"></a><!-- doxytag: member="libircclient.h::irc_cmd_quit" ref="a89bd6efb6dacf53f25ca5518a5aa4ee" args="(irc_session_t *session, const char *reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_quit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends QUIT command to the IRC server. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>A reason to quit. May be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function sends the QUIT command to the IRC server. This command forces the IRC server to close the IRC connection, and terminate the session. 
</div>
</div><p>
<a class="anchor" name="e088b8e83e3482875ea3d3f970dbb9a2"></a><!-- doxytag: member="libircclient.h::irc_cmd_topic" ref="e088b8e83e3482875ea3d3f970dbb9a2" args="(irc_session_t *session, const char *channel, const char *topic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_topic           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Views or changes the channel topic. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel name to invite to. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>A new topic to change. If NULL, the old topic will be returned, and topic won't changed.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
The <a class="el" href="libircclient_8h.html#e088b8e83e3482875ea3d3f970dbb9a2" title="Views or changes the channel topic.">irc_cmd_topic()</a> is used to change or view the topic of a channel. The topic for <em>channel</em> is returned if <em>topic</em> is NULL. If the <em>topic</em> is not NULL, the topic for the <em>channel</em> will be changed. Note that, depending on <em>+t</em> channel mode, you may be required to be a channel operator to change the channel topic.<p>
If the command succeed, the IRC server will generate a RPL_NOTOPIC or RPL_TOPIC message, containing either old or changed topic. Also the IRC server can (but not have to) generate the non-RFC RPL_TOPIC_EXTRA message, containing the nick of person, who's changed the topic, and the time of latest topic change.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#b3fc9166c154ed2b99c0294f5ce31777" title="461 &lt;command&gt; :Not enough parameters">LIBIRC_RFC_ERR_NEEDMOREPARAMS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#45e953e4c730a2f091d74430eeac1d57" title="482 &lt;channel&gt; :You&#39;re not channel operator">LIBIRC_RFC_ERR_CHANOPRIVSNEEDED</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li></ul>
<p>
And the topic information is returned using one of following reply codes:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#f467ce06debba2e77db229b14f5bbe38" title="331 &lt;channel&gt; :No topic is set">LIBIRC_RFC_RPL_NOTOPIC</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#02d7f6f775a11abd3c09bca16d6cdc59" title="332 &lt;channel&gt; :&lt;topic&gt;">LIBIRC_RFC_RPL_TOPIC</a></li></ul>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="structirc__callbacks__t.html#8a5ab3ffc89e19d5748c58bb675436b5">irc_callbacks_t::event_topic</a> <a class="el" href="libircclient_8h.html#63489434dcf78d454389b7744624c1e7" title="Views or changes the channel mode.">irc_cmd_channel_mode</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="71b0c8a534600d2b354be35e28735513"></a><!-- doxytag: member="libircclient.h::irc_cmd_user_mode" ref="71b0c8a534600d2b354be35e28735513" args="(irc_session_t *session, const char *mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_user_mode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Views or changes your own user mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>A user mode, described below. If NULL, the user mode is not changed, just the old mode is returned.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
The <a class="el" href="libircclient_8h.html#71b0c8a534600d2b354be35e28735513" title="Views or changes your own user mode.">irc_cmd_user_mode()</a> is used to change or view the user modes. Note that, unlike channel modes, not all user modes can be changed. The user mode is returned if the <em>mode</em> is NULL. If the <em>mode</em> is not NULL, the mode for you will be changed, and new mode will be returned.<p>
Like channel mode, user mode is also represended by the letters combination. All the user mode letters are boolean (i.e. could only be set or reset), they are set by adding a plus sign before the letter, and reset by adding a minus sign before the letter.<p>
Here is the list of 'standard' user modes:<p>
<ul>
<li><em>o</em> - represents an IRC operator status. Could not be set directly (but can be reset though), to set it use the IRC <em>OPER</em> command.</li></ul>
<p>
<ul>
<li><em>i</em> - if set, marks a user as 'invisible' - that is, not seen by lookups if the user is not in a channel.</li></ul>
<p>
<ul>
<li><em>w</em> - if set, marks a user as 'receiving wallops' - special messages generated by IRC operators using WALLOPS command.</li></ul>
<p>
<ul>
<li><em>s</em> - if set, marks a user for receipt of server notices.</li></ul>
<p>
<ul>
<li><em>r</em> - NON-STANDARD MODE. If set, user has been authenticated with NICKSERV IRC service.</li></ul>
<p>
<ul>
<li><em>x</em> - NON-STANDARD MODE. If set, user's real IP is hidden by IRC servers, to prevent scriptkiddies to do nasty things to the user's computer.</li></ul>
<p>
Note that the actual list of user modes depends on the IRC server, and can be bigger. If you know the popular user modes, which aren't mentioned here - please contact me at <a href="mailto:tim@krasnogorsk.ru">tim@krasnogorsk.ru</a><p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#b3fc9166c154ed2b99c0294f5ce31777" title="461 &lt;command&gt; :Not enough parameters">LIBIRC_RFC_ERR_NEEDMOREPARAMS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#66d80c7acd49ba08f1a14b8775347ed1" title="472 &lt;char&gt; :is unknown mode char to me for &lt;channel&gt;">LIBIRC_RFC_ERR_UNKNOWNMODE</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#109b90448c6e8f7e2537a5f4f323745b" title="502 :Cannot change mode for other users">LIBIRC_RFC_ERR_USERSDONTMATCH</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#0c3eb9db119a7f1b9c8c9be9e9b82ae1" title="501 :Unknown MODE flag">LIBIRC_RFC_ERR_UMODEUNKNOWNFLAG</a></li></ul>
<p>
And the mode information is given using reply code <a class="el" href="libirc__rfcnumeric_8h.html#dad4d02196dcef34bd0627b428f60863" title="221 &lt;user mode string&gt;">LIBIRC_RFC_RPL_UMODEIS</a> 
</div>
</div><p>
<a class="anchor" name="7cfe0b48a060c5291ef1d59a3ea79b4f"></a><!-- doxytag: member="libircclient.h::irc_cmd_whois" ref="7cfe0b48a060c5291ef1d59a3ea79b4f" args="(irc_session_t *session, const char *nick)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_cmd_whois           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nick</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Queries the information about the nick. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A nick to query the information abour. Must not be NULL. A comma-separated list of several nicknames may be given.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function queries various information about the nick: username, real name, the IRC server used, the channels user is in, idle time, away mode and so on.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#8108addfd19326f00eacd71c26809348" title="402 &lt;server name&gt; :No such server">LIBIRC_RFC_ERR_NOSUCHSERVER</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#c754b9522b1f4c4376f809d2e3acbee4" title="431 :No nickname given">LIBIRC_RFC_ERR_NONICKNAMEGIVEN</a></li></ul>
<p>
And the information is returned using the following reply codes. The whois query is completed when <a class="el" href="libirc__rfcnumeric_8h.html#e8c2ae654f4d2502eeea46cd6116687f" title="318 &lt;nick&gt; :End of WHOIS list">LIBIRC_RFC_RPL_ENDOFWHOIS</a> message is received.<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#401ee0bce20717f8fc20240158d9eed3" title="311 &lt;nick&gt; &lt;user&gt; &lt;host&gt; * :&lt;real name&gt;">LIBIRC_RFC_RPL_WHOISUSER</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#61c0201bfafc1f0b39f49dbadbffe4a9" title="319 &quot;&lt;nick&gt; :*( ( &quot;@&quot; / &quot;+&quot; ) &lt;channel&gt; &quot;...">LIBIRC_RFC_RPL_WHOISCHANNELS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#7df656c3ce9c9d2e0b9cf84e5672beca" title="312 &lt;nick&gt; &lt;server&gt; :&lt;server info&gt;">LIBIRC_RFC_RPL_WHOISSERVER</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#54aa2b97df3fc570572e68fc88647143" title="301 &lt;nick&gt; :&lt;away message&gt;">LIBIRC_RFC_RPL_AWAY</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#992b1c08e5c48abc86701826d25a2884" title="313 &lt;nick&gt; :is an IRC operator">LIBIRC_RFC_RPL_WHOISOPERATOR</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#af3e96b0ee5bb9b9e3a3e28e2d75f6e4" title="317 &lt;nick&gt; &lt;integer&gt; :seconds idle">LIBIRC_RFC_RPL_WHOISIDLE</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#e8c2ae654f4d2502eeea46cd6116687f" title="318 &lt;nick&gt; :End of WHOIS list">LIBIRC_RFC_RPL_ENDOFWHOIS</a> </li></ul>

</div>
</div><p>
<a class="anchor" name="bb894bace7c39c70b5582bcdb4052bea"></a><!-- doxytag: member="libircclient.h::irc_color_convert_from_mirc" ref="bb894bace7c39c70b5582bcdb4052bea" args="(const char *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * irc_color_convert_from_mirc           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>message</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts all the color codes and format options to libircclient colors. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>A message from IRC</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a new message with converted mIRC color codes and format options. See the <a class="el" href="libircclient_8h.html#7a9a3490741e2883695759ba5f4adc1e" title="Converts all the color codes from libircclient format to mIRC.">irc_color_convert_to_mirc()</a> help to see how the colors are converted.<br>
 Note that the memory for the new message is allocated using malloc(), so you should free it using free() when it is not used anymore. If memory allocation failed, returns 0.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#2b94751f30cf4cdf444345808fe4ed6c" title="Removes all the color codes and format options.">irc_color_strip_from_mirc</a> <a class="el" href="libircclient_8h.html#7a9a3490741e2883695759ba5f4adc1e" title="Converts all the color codes from libircclient format to mIRC.">irc_color_convert_to_mirc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a9a3490741e2883695759ba5f4adc1e"></a><!-- doxytag: member="libircclient.h::irc_color_convert_to_mirc" ref="7a9a3490741e2883695759ba5f4adc1e" args="(const char *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * irc_color_convert_to_mirc           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>message</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts all the color codes from libircclient format to mIRC. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>A message with color codes</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a new message with converted color codes and format options, or 0 if memory could not be allocated. Note that the memory for the new message is allocated using malloc(), so you should free it using free() when it is not used anymore.</dd></dl>
The color system of libircclient is designed to be easy to use, and portable between different IRC clients. Every color or format option is described using plain text commands written between square brackets. The possible codes are:<ul>
<li>[B] ... [/B] - bold format mode. Everything between [B] and [/B] is written in <b>bold</b>.</li><li>[I] ... [/I] - italic/reverse format mode. Everything between [I] and [/I] is written in <code>italic</code>, or reversed (however, because some clients are incapable of rendering italic text, most clients display this as normal text with the background and foreground colors swapped).</li><li>[U] ... [/U] - underline format mode. Everything between [U] and [/U] is written underlined.</li><li>[COLOR=RED] ... [/COLOR] - write the text using specified foreground color. The color is set by using the <code>COLOR</code> keyword, and equal sign followed by text color code (see below).</li><li>[COLOR=RED/BLUE] ... [/COLOR] - write the text using specified foreground and background color. The color is set by using the <code>COLOR</code> keyword, an equal sign followed by text foreground color code, a dash and a text background color code.</li></ul>
<p>
The supported text colors are:<ul>
<li>WHITE</li><li>BLACK</li><li>DARKBLUE</li><li>DARKGREEN</li><li>RED</li><li>BROWN</li><li>PURPLE</li><li>OLIVE</li><li>YELLOW</li><li>GREEN</li><li>TEAL</li><li>CYAN</li><li>BLUE</li><li>MAGENTA</li><li>DARKGRAY</li><li>LIGHTGRAY</li></ul>
<p>
Examples of color sequences: <div class="fragment"><pre class="fragment"> Hello, [B]Tim[/B]. 
 [U]Arsenal[/U] got a [COLOR=RED]red card[/COLOR]
 The tree[U]s[/U] are [COLOR=GREEN/BLACK]green[/COLOR]
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#2b94751f30cf4cdf444345808fe4ed6c" title="Removes all the color codes and format options.">irc_color_strip_from_mirc</a> <a class="el" href="libircclient_8h.html#bb894bace7c39c70b5582bcdb4052bea" title="Converts all the color codes and format options to libircclient colors.">irc_color_convert_from_mirc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b94751f30cf4cdf444345808fe4ed6c"></a><!-- doxytag: member="libircclient.h::irc_color_strip_from_mirc" ref="2b94751f30cf4cdf444345808fe4ed6c" args="(const char *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * irc_color_strip_from_mirc           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>message</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes all the color codes and format options. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>A message from IRC</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns a new plain text message with stripped mIRC color codes. Note that the memory for the new message is allocated using malloc(), so you should free it using free() when it is not used anymore. If memory allocation failed, returns 0.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#bb894bace7c39c70b5582bcdb4052bea" title="Converts all the color codes and format options to libircclient colors.">irc_color_convert_from_mirc</a> <a class="el" href="libircclient_8h.html#7a9a3490741e2883695759ba5f4adc1e" title="Converts all the color codes from libircclient format to mIRC.">irc_color_convert_to_mirc</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="121b23c9e131da651175ae779e1b6851"></a><!-- doxytag: member="libircclient.h::irc_connect" ref="121b23c9e131da651175ae779e1b6851" args="(irc_session_t *session, const char *server, unsigned short port, const char *server_password, const char *nick, const char *username, const char *realname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_connect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>server_password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>username</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>realname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiates a connection to IRC server. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>A session to initiate connections on. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>server</em>&nbsp;</td><td>A domain name or an IP address of the IRC server to connect to. Cannot be NULL. If the library is built with SSL support and the first character is hash, tries to establish the SSL connection. For example, the connection to "irc.example.com" is assumed to be plaintext, and connection to "#irc.example.com" is assumed to be secured by SSL. Note that SSL will only work if the library is built with the SSL support. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>An IRC server port, usually 6667. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>server_password</em>&nbsp;</td><td>An IRC server password, if the server requires it. May be NULL, in this case password will not be send to the IRC server. Vast majority of IRC servers do not require passwords. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A nick, which libircclient will use to login to the IRC server. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>username</em>&nbsp;</td><td>A username of the account, which is used to connect to the IRC server. This is for information only, will be shown in "user properties" dialogs and returned by /whois request. May be NULL, in this case 'nobody' will be sent as username. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>realname</em>&nbsp;</td><td>A real name of the person, who connects to the IRC. Usually people put some wide-available information here (URL, small description or something else). This information also will be shown in "user properties" dialogs and returned by /whois request. May be NULL, in this case 'noname' will be sent as username.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function prepares and initiates a connection to the IRC server. The connection is done asynchronously (see <a class="el" href="structirc__callbacks__t.html#7294e75ca74ba6dc2b5c18ef8e7795a2">irc_callbacks_t::event_connect</a>), so the success return value means that connection was initiated (but not completed!) successfully.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#112631b75eb9997868d73fede17440d0" title="Goes into forever-loop, processing IRC events and generating callbacks.">irc_run</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5729f584833d55510ae114c8ac3d8e99"></a><!-- doxytag: member="libircclient.h::irc_connect6" ref="5729f584833d55510ae114c8ac3d8e99" args="(irc_session_t *session, const char *server, unsigned short port, const char *server_password, const char *nick, const char *username, const char *realname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_connect6           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>server</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>server_password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>username</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>realname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiates a connection to IRC server using IPv6. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>A session to initiate connections on. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>server</em>&nbsp;</td><td>A domain name or an IP address of the IRC server to connect to. Cannot be NULL. If the library is built with SSL support and the first character is hash, tries to establish the SSL connection. For example, the connection to "irc.example.com" is assumed to be plaintext, and connection to "#irc.example.com" is assumed to be secured by SSL. Note that SSL will only work if the library is built with the SSL support. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>An IRC server port, usually 6667. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>server_password</em>&nbsp;</td><td>An IRC server password, if the server requires it. May be NULL, in this case password will not be send to the IRC server. Vast majority of IRC servers do not require passwords. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A nick, which libircclient will use to login to the IRC server. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>username</em>&nbsp;</td><td>A username of the account, which is used to connect to the IRC server. This is for information only, will be shown in "user properties" dialogs and returned by /whois request. May be NULL, in this case 'nobody' will be sent as username. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>realname</em>&nbsp;</td><td>A real name of the person, who connects to the IRC. Usually people put some wide-available information here (URL, small description or something else). This information also will be shown in "user properties" dialogs and returned by /whois request. May be NULL, in this case 'noname' will be sent as username.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function prepares and initiates a connection to the IRC server. The connection is done asynchronously (see <a class="el" href="structirc__callbacks__t.html#7294e75ca74ba6dc2b5c18ef8e7795a2">irc_callbacks_t::event_connect</a>), so the success return value means that connection was initiated (but not completed!) successfully.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#112631b75eb9997868d73fede17440d0" title="Goes into forever-loop, processing IRC events and generating callbacks.">irc_run</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c5dada35ee77795d8bb77b6701853b98"></a><!-- doxytag: member="libircclient.h::irc_create_session" ref="c5dada35ee77795d8bb77b6701853b98" args="(irc_callbacks_t *callbacks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> * irc_create_session           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structirc__callbacks__t.html">irc_callbacks_t</a> *&nbsp;</td>
          <td class="paramname"> <em>callbacks</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates and initiates a new IRC session. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callbacks</em>&nbsp;</td><td>A structure, which defines several callbacks, which will be called on appropriate events. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5" title="A libircclient IRC session.">irc_session_t</a> object, or 0 if creation failed. Usually, failure is caused by out of memory error.</dd></dl>
Every <a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5" title="A libircclient IRC session.">irc_session_t</a> object describes a single IRC session - a connection to an IRC server, and possibly to some DCC clients. Almost every irc_* function requires this object to be passed to, and therefore this function should be called first.<p>
Every session created must be destroyed when it is not needed anymore by calling <a class="el" href="libircclient_8h.html#30c6cea4f149632d1905b097a3a573f7" title="Destroys previously created IRC session.">irc_destroy_session()</a>.<p>
The most common function sequence is: <div class="fragment"><pre class="fragment">  ... prepare <a class="code" href="structirc__callbacks__t.html" title="Event callbacks structure.">irc_callbacks_t</a> structure ...
  <a class="code" href="libircclient_8h.html#c5dada35ee77795d8bb77b6701853b98" title="Creates and initiates a new IRC session.">irc_create_session</a>();
  <a class="code" href="libircclient_8h.html#121b23c9e131da651175ae779e1b6851" title="Initiates a connection to IRC server.">irc_connect</a>();
  <a class="code" href="libircclient_8h.html#112631b75eb9997868d73fede17440d0" title="Goes into forever-loop, processing IRC events and generating callbacks.">irc_run</a>();
  <a class="code" href="libircclient_8h.html#30c6cea4f149632d1905b097a3a573f7" title="Destroys previously created IRC session.">irc_destroy_session</a>();
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#30c6cea4f149632d1905b097a3a573f7" title="Destroys previously created IRC session.">irc_destroy_session</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="43f747d3b2252109f9d811ea8414745b"></a><!-- doxytag: member="libircclient.h::irc_dcc_accept" ref="43f747d3b2252109f9d811ea8414745b" args="(irc_session_t *session, irc_dcc_t dccid, void *ctx, irc_dcc_callback_t callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_dcc_accept           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a>&nbsp;</td>
          <td class="paramname"> <em>dccid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9">irc_dcc_callback_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accepts a remote DCC CHAT or DCC RECVFILE request. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dccid</em>&nbsp;</td><td>A DCC session ID, returned by appropriate callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>A user-supplied DCC session context, which will be passed to the DCC callback function. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A DCC callback function, which will be called when anything is said by other party. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>.</dd></dl>
This function accepts a remote DCC request - either DCC CHAT or DCC FILE. After the request is accepted, the supplied callback will be called, and you can start sending messages or receiving the file.<p>
This function should be called only after either event_dcc_chat_req or event_dcc_send_req events are generated, and should react to them. It is possible not to call irc_dcc_accept or irc_dcc_decline immediately in callback function - you may just return, and call it later. However, to prevent memory leaks, you must call either irc_dcc_decline or irc_dcc_accept for any incoming DCC request.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#3ff4ca78d346b7acf847cf28a7211bf4" title="Declines a remote DCC CHAT or DCC RECVFILE request.">irc_dcc_decline</a> event_dcc_chat_req event_dcc_send_req </dd></dl>

</div>
</div><p>
<a class="anchor" name="d6958aac6d67f595966949d1ec5ae4a0"></a><!-- doxytag: member="libircclient.h::irc_dcc_chat" ref="d6958aac6d67f595966949d1ec5ae4a0" args="(irc_session_t *session, void *ctx, const char *nick, irc_dcc_callback_t callback, irc_dcc_t *dccid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_dcc_chat           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9">irc_dcc_callback_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dccid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initiates a DCC CHAT. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>A user-supplied DCC session context, which will be passed to the DCC callback function. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A nick to DCC CHAT with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A DCC callback function, which will be called when anything is said by other party. Must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dccid</em>&nbsp;</td><td>On success, DCC session ID will be stored in this var.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function requests a DCC CHAT between you and other user. For newbies, DCC chat is like private chat, but it goes directly between two users, and bypasses IRC server. DCC CHAT request must be accepted by other side before you can send anything.<p>
When the chat is accepted, terminated, or some data is received, the callback function is called. See the details in irc_dcc_callback_t declaration.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#73d5c17577fddd176f2d89e15b657c1a" title="411 :No recipient given (&lt;command&gt;)">LIBIRC_RFC_ERR_NORECIPIENT</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#c9851022435108cc6074c8cab2311b58" title="412 :No text to send">LIBIRC_RFC_ERR_NOTEXTTOSEND</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#3624990fe128d867c11b213228e62df8" title="404 &lt;channel name&gt; :Cannot send to channel">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#fcad763cc97b268aa585311350989dca" title="413 &lt;mask&gt; :No toplevel domain specified">LIBIRC_RFC_ERR_NOTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#4cf5ceeec3305180731860436650c955" title="414 &lt;mask&gt; :Wildcard in toplevel domain">LIBIRC_RFC_ERR_WILDTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#807eab621113410281fd574de71236ea" title="407 &lt;target&gt; :&lt;error code&gt; recipients. &lt;abort message&gt;">LIBIRC_RFC_ERR_TOOMANYTARGETS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li></ul>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9" title="A common DCC callback, used to inform you about the current DCC state or event.">irc_dcc_callback_t</a> <a class="el" href="libircclient_8h.html#b98b7ea58a36d7649c2dca6c4b3c8a7d" title="Sends the message to the specific DCC CHAT.">irc_dcc_msg</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ff4ca78d346b7acf847cf28a7211bf4"></a><!-- doxytag: member="libircclient.h::irc_dcc_decline" ref="3ff4ca78d346b7acf847cf28a7211bf4" args="(irc_session_t *session, irc_dcc_t dccid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_dcc_decline           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a>&nbsp;</td>
          <td class="paramname"> <em>dccid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Declines a remote DCC CHAT or DCC RECVFILE request. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dccid</em>&nbsp;</td><td>A DCC session ID, returned by appropriate callback.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>.</dd></dl>
This function declines a remote DCC request - either DCC CHAT or DCC FILE.<p>
This function should be called only after either event_dcc_chat_req or event_dcc_send_req events are generated, and should react to them. It is possible not to call irc_dcc_accept or irc_dcc_decline immediately in callback function - you may just return, and call it later. However, to prevent memory leaks, you must call either irc_dcc_decline or irc_dcc_accept for any incoming DCC request.<p>
Do not use this function to close the accepted or initiated DCC session. Use irc_dcc_destroy instead.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#43f747d3b2252109f9d811ea8414745b" title="Accepts a remote DCC CHAT or DCC RECVFILE request.">irc_dcc_accept</a> <a class="el" href="structirc__callbacks__t.html#fbaf019778a64b544093ee29da5b3c81">irc_callbacks_t::event_dcc_chat_req</a> <a class="el" href="structirc__callbacks__t.html#2ac9d08921faee2472ed16d41799887d">irc_callbacks_t::event_dcc_send_req</a> <a class="el" href="libircclient_8h.html#8b8aa3363ee93cc395bc89ac5cc9501c" title="Destroys a DCC session.">irc_dcc_destroy</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b8aa3363ee93cc395bc89ac5cc9501c"></a><!-- doxytag: member="libircclient.h::irc_dcc_destroy" ref="8b8aa3363ee93cc395bc89ac5cc9501c" args="(irc_session_t *session, irc_dcc_t dccid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_dcc_destroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a>&nbsp;</td>
          <td class="paramname"> <em>dccid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys a DCC session. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dccid</em>&nbsp;</td><td>A DCC session ID.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>.</dd></dl>
This function closes the DCC connection (if available), and destroys the DCC session, freeing the used resources. It can be called in any moment, even from callbacks or from different threads.<p>
Note that when DCC session is finished (either with success or failure), you should not destroy it - it will be destroyed automatically. 
</div>
</div><p>
<a class="anchor" name="b98b7ea58a36d7649c2dca6c4b3c8a7d"></a><!-- doxytag: member="libircclient.h::irc_dcc_msg" ref="b98b7ea58a36d7649c2dca6c4b3c8a7d" args="(irc_session_t *session, irc_dcc_t dccid, const char *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_dcc_msg           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a>&nbsp;</td>
          <td class="paramname"> <em>dccid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends the message to the specific DCC CHAT. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An IRC session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dccid</em>&nbsp;</td><td>A DCC session ID, which chat request must have been accepted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>text</em>&nbsp;</td><td>Message text. Must not be NULL.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>.</dd></dl>
This function is used to send the DCC CHAT messages. DCC CHAT request must be initiated and accepted first (or just accepted, if initiated by other side).<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#d6958aac6d67f595966949d1ec5ae4a0" title="Initiates a DCC CHAT.">irc_dcc_chat</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f9e8a307113cd27d08e082fda6264262"></a><!-- doxytag: member="libircclient.h::irc_dcc_sendfile" ref="f9e8a307113cd27d08e082fda6264262" args="(irc_session_t *session, void *ctx, const char *nick, const char *filename, irc_dcc_callback_t callback, irc_dcc_t *dccid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_dcc_sendfile           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9">irc_dcc_callback_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#4136d52803e88f369d728e1e3b0e70f7">irc_dcc_t</a> *&nbsp;</td>
          <td class="paramname"> <em>dccid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a file via DCC. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>A user-supplied DCC session context, which will be passed to the DCC callback function. May be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A nick to send file via DCC to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>A file name to sent. Must be an existing file. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>A DCC callback function, which will be called when file sent operation is failed, progressed or completed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dccid</em>&nbsp;</td><td>On success, DCC session ID will be stored in this var.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function generates a DCC SEND request to send the file. When it is accepted, the file is sent to the remote party, and the DCC session is closed. The send operation progress and result can be checked in callback. See the details in irc_dcc_callback_t declaration.<p>
Possible error responces for this command from the RFC1459:<ul>
<li><a class="el" href="libirc__rfcnumeric_8h.html#73d5c17577fddd176f2d89e15b657c1a" title="411 :No recipient given (&lt;command&gt;)">LIBIRC_RFC_ERR_NORECIPIENT</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#c9851022435108cc6074c8cab2311b58" title="412 :No text to send">LIBIRC_RFC_ERR_NOTEXTTOSEND</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#3624990fe128d867c11b213228e62df8" title="404 &lt;channel name&gt; :Cannot send to channel">LIBIRC_RFC_ERR_CANNOTSENDTOCHAN</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#b20af2b80994d5c9d7c1e96d88f2e577" title="442 &lt;channel&gt; :You&#39;re not on that channel">LIBIRC_RFC_ERR_NOTONCHANNEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#fcad763cc97b268aa585311350989dca" title="413 &lt;mask&gt; :No toplevel domain specified">LIBIRC_RFC_ERR_NOTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#4cf5ceeec3305180731860436650c955" title="414 &lt;mask&gt; :Wildcard in toplevel domain">LIBIRC_RFC_ERR_WILDTOPLEVEL</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#807eab621113410281fd574de71236ea" title="407 &lt;target&gt; :&lt;error code&gt; recipients. &lt;abort message&gt;">LIBIRC_RFC_ERR_TOOMANYTARGETS</a></li><li><a class="el" href="libirc__rfcnumeric_8h.html#28f90d5f34a3056127516c0edc7c511f" title="401 &lt;nickname&gt; :No such nick/channel">LIBIRC_RFC_ERR_NOSUCHNICK</a></li></ul>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#92d4d3f7866bd8c4f1d6df8f05d939f9" title="A common DCC callback, used to inform you about the current DCC state or event.">irc_dcc_callback_t</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="30c6cea4f149632d1905b097a3a573f7"></a><!-- doxytag: member="libircclient.h::irc_destroy_session" ref="30c6cea4f149632d1905b097a3a573f7" args="(irc_session_t *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irc_destroy_session           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys previously created IRC session. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>A session to destroy. Must not be NULL.</td></tr>
  </table>
</dl>
This function should be used to destroy an IRC session, close the connection to the IRC server, and free all the used resources. After calling this function, you should not use this session object anymore. 
</div>
</div><p>
<a class="anchor" name="a5f6dd73d3f0bdecb53f53362e253aab"></a><!-- doxytag: member="libircclient.h::irc_disconnect" ref="a5f6dd73d3f0bdecb53f53362e253aab" args="(irc_session_t *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irc_disconnect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disconnects a connection to IRC server. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An IRC session.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>.</dd></dl>
This function closes the IRC connection. After that connection is closed, libircclient automatically leaves irc_run loop.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#121b23c9e131da651175ae779e1b6851" title="Initiates a connection to IRC server.">irc_connect</a> <a class="el" href="libircclient_8h.html#112631b75eb9997868d73fede17440d0" title="Goes into forever-loop, processing IRC events and generating callbacks.">irc_run</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3a18336093ee74751244d996bc32247d"></a><!-- doxytag: member="libircclient.h::irc_errno" ref="3a18336093ee74751244d996bc32247d" args="(irc_session_t *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_errno           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last error code. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated session.</td></tr>
  </table>
</dl>
This function returns the last error code associated with last operation of this IRC session. Possible error codes are defined in <a class="el" href="libirc__errors_8h.html">libirc_errors.h</a><p>
As usual, next errno rules apply:<ul>
<li><a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a> should be called ONLY if the called function fails;</li><li><a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a> doesn't return 0 if function succeed; actually, the return value will be undefined.</li><li>you should call <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a> IMMEDIATELY after function fails, before calling any other libircclient function.</li></ul>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#fdc70ca04626818d2fd9a55da0b90e5f" title="Returns the text error message associated with this error code.">irc_strerror</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="341a8954613f29c7ff5a92413398ce7d"></a><!-- doxytag: member="libircclient.h::irc_get_ctx" ref="341a8954613f29c7ff5a92413398ce7d" args="(irc_session_t *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * irc_get_ctx           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the IRC session context. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated session.</td></tr>
  </table>
</dl>
This function returns the IRC session context, which was set by <a class="el" href="libircclient_8h.html#e0cf439a36aafce4abab8f4cce5ac5ff" title="Sets the IRC session context.">irc_set_ctx()</a>. If no context was set, this function returns NULL.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#e0cf439a36aafce4abab8f4cce5ac5ff" title="Sets the IRC session context.">irc_set_ctx</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ebc090ad2392569b1998d7e2354c7bc7"></a><!-- doxytag: member="libircclient.h::irc_get_version" ref="ebc090ad2392569b1998d7e2354c7bc7" args="(unsigned int *high, unsigned int *low)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irc_get_version           </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>low</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtains a libircclient version. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>high</em>&nbsp;</td><td>A pointer to receive the high version part. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>low</em>&nbsp;</td><td>A pointer to receive the low version part.</td></tr>
  </table>
</dl>
This function returns the libircclient version. You can use the version either to check whether required options are available, or to output the version. The preferred printf-like format string to output the version is:<p>
printf ("Version: %d.%02d", high, low); 
</div>
</div><p>
<a class="anchor" name="90f826583118cb2e34135cb0e9b26cf8"></a><!-- doxytag: member="libircclient.h::irc_is_connected" ref="90f826583118cb2e34135cb0e9b26cf8" args="(irc_session_t *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_is_connected           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks whether the session is connecting/connected to the IRC server. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initialized IRC session.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 1 means that session is connecting or connected to the IRC server, zero value means that the session has been disconnected.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#121b23c9e131da651175ae779e1b6851" title="Initiates a connection to IRC server.">irc_connect</a> <a class="el" href="libircclient_8h.html#112631b75eb9997868d73fede17440d0" title="Goes into forever-loop, processing IRC events and generating callbacks.">irc_run</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f56687ccad2045204ae23f70d2f54860"></a><!-- doxytag: member="libircclient.h::irc_option_reset" ref="f56687ccad2045204ae23f70d2f54860" args="(irc_session_t *session, unsigned int option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irc_option_reset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the libircclient option. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>An option from <a class="el" href="libirc__options_8h.html">libirc_options.h</a></td></tr>
  </table>
</dl>
This function removes the previously set libircclient option, changing libircclient behavior. See the option list for the meaning for every option.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#c5d81f651f1441690f3f59c3ddccaa48" title="Sets the libircclient option.">irc_option_set</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c5d81f651f1441690f3f59c3ddccaa48"></a><!-- doxytag: member="libircclient.h::irc_option_set" ref="c5d81f651f1441690f3f59c3ddccaa48" args="(irc_session_t *session, unsigned int option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irc_option_set           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the libircclient option. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>An option from <a class="el" href="libirc__options_8h.html">libirc_options.h</a></td></tr>
  </table>
</dl>
This function sets the libircclient option, changing libircclient behavior. See the option list for the meaning for every option.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#f56687ccad2045204ae23f70d2f54860" title="Resets the libircclient option.">irc_option_reset</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4526d10056559eac7bd777437d440170"></a><!-- doxytag: member="libircclient.h::irc_process_select_descriptors" ref="4526d10056559eac7bd777437d440170" args="(irc_session_t *session, fd_set *in_set, fd_set *out_set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_process_select_descriptors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&nbsp;</td>
          <td class="paramname"> <em>in_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fd_set *&nbsp;</td>
          <td class="paramname"> <em>out_set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Processes the IRC socket(s), which descriptor(s) are set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>in_set</em>&nbsp;</td><td>A FD_IN descriptor set for select() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_set</em>&nbsp;</td><td>A FD_OUT descriptor set for select()</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>.</dd></dl>
This function should be used in pair with irc_add_select_descriptors function. See irc_add_select_descriptors description.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#75d2af4209ad2edbdbff77b0cfcabcab" title="Adds IRC socket(s) for the descriptor set to use in select().">irc_add_select_descriptors</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="112631b75eb9997868d73fede17440d0"></a><!-- doxytag: member="libircclient.h::irc_run" ref="112631b75eb9997868d73fede17440d0" args="(irc_session_t *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_run           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Goes into forever-loop, processing IRC events and generating callbacks. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>.</dd></dl>
This function goes into forever loop, processing the IRC events, and calling appropriate callbacks. This function will not return until the server connection is terminated - either by server, or by calling irc_cmd_quit. This function should be used, if you don't need asynchronous request processing (i.e. your bot just reacts on the events, and doesn't generate it asynchronously). Even in last case, you still can call irc_run, and start the asynchronous thread in event_connect handler. See examples. 
</div>
</div><p>
<a class="anchor" name="d69addf9c9e45d888a71d6295429e05c"></a><!-- doxytag: member="libircclient.h::irc_send_raw" ref="d69addf9c9e45d888a71d6295429e05c" args="(irc_session_t *session, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int irc_send_raw           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends raw data to the IRC server. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated and connected session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td>A printf-formatted string, followed by function args.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Return code 0 means success. Other value means error, the error code may be obtained through <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a>. Any error, generated by the IRC server, is available through <a class="el" href="structirc__callbacks__t.html#85951d45acff22aea37a822bb9c7aef7">irc_callbacks_t::event_numeric</a>.</dd></dl>
This function sends the raw data as-is to the IRC server. Use it to generate a server command, which is not (yet) provided by libircclient directly. 
</div>
</div><p>
<a class="anchor" name="e0cf439a36aafce4abab8f4cce5ac5ff"></a><!-- doxytag: member="libircclient.h::irc_set_ctx" ref="e0cf439a36aafce4abab8f4cce5ac5ff" args="(irc_session_t *session, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irc_set_ctx           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libircclient_8h.html#0030a976ab3e6a247d57e30fd5979cd5">irc_session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the IRC session context. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>An initiated session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>A context.</td></tr>
  </table>
</dl>
This function sets the user-defined context for this IRC session. This context is not used by libircclient. Its purpose is to store session-specific user data, which may be obtained later by calling <a class="el" href="libircclient_8h.html#341a8954613f29c7ff5a92413398ce7d" title="Returns the IRC session context.">irc_get_ctx()</a>. Note that libircclient just 'carries out' this pointer. If you allocate some memory, and store its address in ctx (most common usage), it is your responsibility to free it before calling <a class="el" href="libircclient_8h.html#30c6cea4f149632d1905b097a3a573f7" title="Destroys previously created IRC session.">irc_destroy_session()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#341a8954613f29c7ff5a92413398ce7d" title="Returns the IRC session context.">irc_get_ctx</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fdc70ca04626818d2fd9a55da0b90e5f"></a><!-- doxytag: member="libircclient.h::irc_strerror" ref="fdc70ca04626818d2fd9a55da0b90e5f" args="(int ircerrno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * irc_strerror           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ircerrno</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the text error message associated with this error code. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ircerrno</em>&nbsp;</td><td>A numeric error code returned by <a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a></td></tr>
  </table>
</dl>
This function returns the text representation of the given error code.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="libircclient_8h.html#3a18336093ee74751244d996bc32247d" title="Returns the last error code.">irc_errno()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5929f96c251be831d1de66e6bba6299c"></a><!-- doxytag: member="libircclient.h::irc_target_get_host" ref="5929f96c251be831d1de66e6bba6299c" args="(const char *target, char *nick, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irc_target_get_host           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the host part from the target. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>A nick in common IRC server form like tim!root@mydomain.com </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A buffer to hold the nickname. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>A buffer size. If nick is longer than buffer size, it will be truncated.</td></tr>
  </table>
</dl>
For most events IRC server returns 'origin' (i.e. the person, who generated this event) in i.e. "common" form, like nick!host@domain. I don't know any command, which requires host, but it may be useful :) This function parses this origin, and gets the host, storing it into user-provided buffer. 
</div>
</div><p>
<a class="anchor" name="217df7c7c7dc5e60678dd14e24e41f03"></a><!-- doxytag: member="libircclient.h::irc_target_get_nick" ref="217df7c7c7dc5e60678dd14e24e41f03" args="(const char *target, char *nick, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irc_target_get_nick           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>nick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the nick part from the target. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>A nick in common IRC server form like tim!root@mycomain.com </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nick</em>&nbsp;</td><td>A buffer to hold the nickname. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>A buffer size. If nick is longer than buffer size, it will be truncated.</td></tr>
  </table>
</dl>
For most events IRC server returns 'origin' (i.e. the person, who generated this event) in i.e. "common" form, like nick!host@domain. However, all the irc_cmd_* functions require just a nick/ This function parses this origin, and gets the nick, storing it into user-provided buffer. A buffer of size 90 should be enough for most nicks :) 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jun 12 17:57:23 2012 for Bot by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
